// /api/streak-data/route.js
const COOKIE_NAME = 'stayhi_session';
function json(data, status = 200) {
  return new Response(JSON.stringify(data), { status, headers: { 'Content-Type': 'application/json' } });
}
function parseCookies(req) {
  const raw = req.headers.get('cookie') || '';
  return Object.fromEntries(raw.split(/;\s*/).filter(Boolean).map(kv => {
    const i = kv.indexOf('=');
    return [decodeURIComponent(kv.slice(0, i)), decodeURIComponent(kv.slice(i + 1))];
  }));
}
function readSession(req) {
  try {
    const raw = parseCookies(req)[COOKIE_NAME];
    const val = raw?.startsWith('{') ? raw : Buffer.from(raw || '', 'base64url').toString('utf8');
    return val ? JSON.parse(val) : null;
  } catch { return null; }
}
function requireEnv() {
  const url = process.env.SUPABASE_URL;
  const key = process.env.SUPABASE_SERVICE_ROLE_KEY;
  if (!url || !key) throw new Error('Missing SUPABASE_URL or SUPABASE_SERVICE_ROLE_KEY');
  return { url, key };
}

export const config = { runtime: 'nodejs18.x' };

export default async function handler(req) {
  if (req.method !== 'POST') return json({ error: 'Method not allowed' }, 405);
  const body = await req.json().catch(() => ({}));
  if (body?.action === 'health') return json({ ok: true, route: 'streak-data' });

  const sess = readSession(req);
  const user = sess?.user;
  if (!user?.id) return json({ error: 'Not signed in' }, 401);

  try {
    const { url, key } = requireEnv();
    // Pull last 120 days of entries (session + checkin)
    const from = new Date(Date.now() - 120*24*60*60*1000).toISOString();

    const r = await fetch(
      `${url}/rest/v1/entries?user_id=eq.${encodeURIComponent(user.id)}&created_at=gte.${from}&select=created_at,kind`,
      { headers: { apikey: key, Authorization: `Bearer ${key}` } }
    );
    const rows = await r.json();
    if (!r.ok) throw new Error(rows?.message || 'Fetch failed');

    // Build set of yyyy-mm-dd days with at least one entry
    const days = new Set(rows.map(x => x.created_at.slice(0,10)));

    // Compute current and best streak (UTC midnight boundaries)
    const today = new Date();
    const dayKey = d => d.toISOString().slice(0,10);
    function addDays(d, n){ const x = new Date(d); x.setUTCDate(x.getUTCDate()+n); return x; }

    // best
    let best = 0, cur = 0;
    let run = 0, prev = null;
    const sorted = Array.from(days).sort(); // ascending
    for (const ymd of sorted) {
      const d = new Date(ymd + 'T00:00:00Z');
      if (prev && dayKey(addDays(prev,1)) === ymd) run += 1; else run = 1;
      if (run > best) best = run;
      prev = d;
    }

    // current (count back from today)
    cur = 0;
    let probe = new Date(Date.UTC(today.getUTCFullYear(), today.getUTCMonth(), today.getUTCDate()));
    while (days.has(dayKey(probe))) {
      cur += 1;
      probe = addDays(probe, -1);
    }

    return json({ current: cur, best, totalDays: days.size });
  } catch (e) {
    return json({ error: e.message || 'Server error' }, 500);
  }
}

